From a7213b8d10da03fde0a6bbe2fdf5022966cd0c76 Mon Sep 17 00:00:00 2001
From: David Mitchell <davem@iabyn.com>
Date: Sun, 29 May 2016 22:20:40 +0100
Subject: [PATCH 8/9] fixup t/13-reap-ctl.t for 5.23.8

One test in this script failed under 5.23.8 due to a change in the way
the die while leaving an eval scope is now handled.

Consider the following code, where leaving an eval scope triggers a call
to STORE to unlocalise a tied scalar, and where STORE raises an exception:

    sub TIESCALAR { bless [] }
    sub FETCH { 1;  }
    sub STORE { die "died in store\n" if $_[1]  }

    tie $s, 'main';
    eval {
        local $s;
    };
    warn "caught: [$@]\n";

5.23.7 and earlier die, while 5.23.8 output:

    caught: [died in store
    ]

Similarly, one would expect the behaviour of "reap HERE" to change
in 5.23.8, with an exception raised in the reap handler to now be caught
be the innermost eval.

So fix up the test to reflect this new reality.
---
 t/13-reap-ctl.t | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/t/13-reap-ctl.t b/t/13-reap-ctl.t
index e4e47b5..085cc05 100644
--- a/t/13-reap-ctl.t
+++ b/t/13-reap-ctl.t
@@ -302,10 +302,12 @@ $y = undef;
    reap { ++$y; die "reaped\n" } => HERE;
    is $x, 3,     'die in reap at eval [not yet - x]';
    is $y, undef, 'die in reap at eval [not yet - y]';
-  }; # should trigger here, but the die isn't catched by this eval
-  die "failed\n";
+  }; # should trigger here, but the die isn't catched by this eval in
+     # ealier perls
+  die "inner\n";
  };
- is $@, "reaped\n", 'die in reap at eval [ok - $@]';
+ is $@, ($] >= 5.023008 ? "inner\n" : "reaped\n"),
+        'die in reap at eval [ok - $@]';
  is $x, 1, 'die in reap at eval [ok - x]';
  is $y, 1, 'die in reap at eval [ok - y]';
 }
-- 
2.8.3

